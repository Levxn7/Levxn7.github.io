---
title: 事件循环
date: 2021-12-04 12:14:11
categories: 
- 高级前端笔记
tags: 
- eventloop
---

#### 一、主题
JS执行中的堆栈（浏览器平台下）
系统的梳理一些底层的知识

#### 二、XXX
基于代码的执行结果我们有必要对这些“简单代码的执行过程” 有一个深刻的理解。
1. 哪些平台可以执行 JS 代码：
+ 浏览器平台 
+ NodejS 
+ webview 

2. 无论 JS 代码在哪些个平台上执行，最终都需要有一个执行的地方
+ 代码最终都是运行在内存当中的
+ 在 JS 执行过的过程中我们认为浏览器加载界面的时候就会向计算机的内存申请一片空间，用于执行 JS 代码
+ 这个空间我们称之为叫 执行环境栈（ ECS execution context stack ）

3. 常见的名词 
+ 执行环境栈：本质就是一个内存空间

+ 执行上下文：( EC(execution context) )
  + 一段JS 代码里肯定会有很多内容：变量的声明、函数的定义、对象、块作用域
  + 上述这些区域内都有自己的代码，默认情况下他们里面的内容可能会出现重名
  + 所以代码将来在执行时候不可能直接放在一个“环境”下去运行，我们需要将它们隔离开
  + JS当中就有了执行上下文的概念，专门用于将不同区域的代码 “分开” 【  】
  + 它也是一个内存空间，我们无须将它具像化。在它里面存放了当前区域代码运行时所需要的数据

+ 进栈执行
  + 执行环境栈具有先进后出的特点（）
  + 每当“一段”代码要运行的时候，就会生成一个新的执行上下文，然后在这个上下文当中将执行时需要的内容准备好，之后就开始进栈执行 

+ EC(G) （execution context global）
  + 全局执行上下文， 浏览器加载界面的时候就默认创建的一个环境 [这个上下文和我们代码执行与否没关系]
  + 当前这个上下文如果想要出栈必然是界面关闭【 垃圾回收 】

+ VO(G) variable object global） 
  + 全局变量对象（ 全局执行上下文当中的变量需要有一个地方来存放，因此就有了这个对象 ）
  + 每一段代码中都有声明和定义，他们放在哪？
  + 针对全局执行上下文来说，它里面的声明和定义放在了一个对象当中，这个对象我们叫 VO(G)

+ GO( global object ) 
  + 全局对象， 它和 VO(G) 不是同一个东西 【 window 】
  + 它也是浏览器加载界面时就会创建的一个对象，在它内部存放了许多JS默认就可以调用的属性和方法（ setTimeout setInterval JSON eval..... ）

+ 声明和定义 
  + 声明： var obj; 
  + 定义： obj = XXXX 

#### 三、堆栈中的基本值 
+ 在EC(G) 当中有 VO(G) 用来存储当前执行上下文里的变量声明和定义 
+ 代码执行之前会有提升操作：对于 var 操作来说只声明不定义【重要】
+ 基本数据类型值是直接存放在栈区当中的 
+ VO(G) 当中默认就有一个window 它存放的是一个内存地址，指向 GO 对象所在内存 

#### 四、堆栈中的引用类型
1. 引用类型在 JS 中会单独开辟一个空间进行存储（堆区）
2. 堆区本质上也是一个内存，因此会有一个16进制的地址 
3. 在栈区当中存放的是这个内存的16进制地址

#### 五、函数在堆栈中的存储
+ 函数的创建
  + 创建函数和声明变量类似，可以将函数名看做是变量名
  + 函数的提升与变量不同，它是既声明又定义（ 函数可以在定义之前调用 ）
  + 函数创建时就会确认自己的作用域（就是当前所在执行上下文）
+ 函数执行  
  + 执行目的就是为了将函数创建时所保存的那些字符串形式的代码运行起来
  + 代码运行时为了和其它上下文做隔离，因此每个函数执行时都会创建一个全新的私有上下文
  + 在这个私有上下文当中有一个 AO(xxx) 用来存储函数上下文里的变量声明和定义 
  + 执行步骤
    + 确定作用域链＜当前执行上下文，函数作用域＞
    + 确定this 指向
    + 初始化 arguments
    + 形参赋值： 这里定义的变量都是当前函数上下文私有的
    + 变量提升 
    + 代码执行  
  + 

#### 六、闭包 
闭包是一种机制，代码是具体表现，例如我们常见 大函数套小函数然后再返回小函数  




#### 写在最后

原创博文, 如有错误, 敬请指导!



