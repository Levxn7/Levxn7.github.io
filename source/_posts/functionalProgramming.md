---
title: 函数式编程
date: 2021-12-24 10:09:22
categories: 
- 高级前端笔记
tags: 
- 高阶函数
- 柯里化
- lodash
---
#### 函数式编程
**函数式编程是—种编程范式**，我们常见的编程范式有命令式编程(lmperative
programming)，函数式编程，逻辑式编程，*常见的面向对象编程是也是一种命令式编程*。

命令式编程是面向计算机硬件的抽象，有变量(对应着存储单元)，赋值语句(获取，存储指令)，表达式(内存引用和算术运算）和控制语句（跳转指令)。
而函数式编程是面向数学的抽象，将计算描述为一种表达式求值，一句话，函数式程序就是一个表达式。

函数式编程中的函数这个术语不是指计算机中的函数(实际上是Subroutine)，而是指**数学中的函数**，即自**变量的映射**。也就是说一个函数的值仅决定于函数参数的值，不依赖其他状态。比如sqrt(x)函数计算x的平方根，只要x不变，不论什么时候调用，调用几次，值都是不变的。
在函数式语言中，**函数作为一等公民**，可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，可以对函数进行组合。

函数式运算的核心，就是把运算过程抽象成函数，合成的过程就是抽象的过程。函数式运算可以最大程度的重用。
函数的名字要有实际性的意义，这对函数式编程来说非常重要。函数式编程经常会使用箭头函数，会使代码更简洁。

##### 高阶函数 
高阶函数的英文名叫 Higher-Order Function，是函数式编程的基本技术。**把函数作为参数传入，这样的函数称为高阶函数**，编写高阶函数，就是让函数的参数能够接收别的函数。函数式编程就是指这种高度抽象的编程范式。

因为在JS中函数是一等公民，即函数可以被赋值给变量，被变量引用，这便使得函数可以作为参数，在其他函数间相互传递。这是JS作为一门“一切皆为对象”的语言，也能拥有函数式编程的能力

闭包（可以判定有基准值的问题）


##### 纯函数
> **函数的副作用**
函数的副作用会让函数变得不纯（函数如果依赖外部变量，就会产生副作用，既是不纯函数）。副作用会使函数通用性下降，不适合扩展和重用，会给程序带来安全隐患。副作用不能完全禁止，只能尽量控制。
副作用来源：全局变量，配置文件，数据库，用户输入等所有的外部交互

纯函数始终有输入和输出，相同的输入一定是相同的输出，没有可观察的副作用。纯函数不会调用外部作用域的变量。使得函数与外部解耦，函数的使用更加安全。

纯函数的好处有：
- 可缓存 可以提高程序的性能
- 可测试
- 并行处理（对比多线程并行操作共享内存数据的意外）


##### 柯里化

> 维基百科：Currying，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。

当函数有多个参数时，可以分解函数，先传递一部分（不变）的参数，然后返回新的函数接收剩余的参数，然后返回结果。

> 示例
```js
// 普通的add函数
function add(x, y) {
    return x + y
}

// Currying后
function curryingAdd(x) {
    return function (y) {
        return x + y
    }}

add(1, 2)           // 3
curryingAdd(1)(2)   // 3
```

实际上就是把add函数的x，y两个参数变成了先用一个函数接收x然后返回一个函数去处理y参数。现在思路应该就比较清晰了，就是只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。

lodash中的柯里化 \_.curry(func)，可以帮我们把多元函数转化为一元函数
如果传入所有参数就返回结果，如果传入部分参数就返回一个函数，使之可以继续传入参数
图12/10-12


**总结**
- 柯里化可以先传递一些函数并返回一个已有某些固定参数的新函数
- 是对函数参数的一种‘缓存’，让参数可以复用
- 让函数变得灵活，颗粒更小 
- 把多远函数变为一元函数，可以组合使用，产生强大的功效

可参考资料
<https://www.jianshu.com/p/2975c25e4d71>


##### 函数的组合compose
其思想为将数据依次经过几个函数处理（函数的嵌套），最终输出结果数据。

函数组合默认是从右到左执行。大函数拆分成小函数，可以容易debug。函数的组合要满足结合律（数学意义上的结合律）

Lodash的\_.flow 提供了 compose 的功能，且可读性更强。\_.flow()从左往右执行 \_.flowRight()从右往左执行

调试函数组合时可以定义一个内含打印和返回的辅助函数

###### lodash中的fp模块
fp模块提供的方法都是经过柯里化的
- 提供了实用的对函数式编程友好的方法
- 函数优先  数据之后

\_.map有个小问题，它会给第二个参数（函数a）传递三个参数(item, index, array)，这就有可能会影响到函数a的运作,而fp中的map函数可以解决这个问题
> 示例
```js
const _ = require('lodash');
const fp = require('lodash/fp');
let arr1 = ['10', '20', '30', '40'];
console.log(_.map(arr1, parseInt));

//执行结果[ 10, NaN, NaN, NaN ]
//parseInt 执行顺序
//parseInt('10',0,array) 10
//parseInt('20',1,array) NAN
//parseInt('30',2,array) NAN
//parseInt('40',3,array) NAN

//解决这个问题使用lodash/fp模块
console.log(fp.map(parseInt, arr1));
//[ 10, 20, 30, 40 ]
```

##### pointfree模式
pointFree：我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。
- 不需要指明处理的数据
- 只需要合成运算过程
- 需要定义一些辅助的基本运算函数

#### 函子Functor
我们学习函子是为了在函数式编程中把副作用控制在可控范围内、作异常处理、异步操作等。我们可以把函子想象成一个盒子，里面有map方法，传进一个值，对值进行处理。
函子是一个特殊的容器（包含值和值的变形关系（函数）），通过一个普通的对象来实现。函子是一个对象，对外提供map方法，永远不取值出来，只在map里对值进行操作。（以_开头的值是私有值，不对外公布。）

总结：
- 函数式编程的运算不直接操作值，而是由函子完成。
- 函子就是一个实现了map契约的对象
- 我们可以把函子想象成一个盒子，这个盒子里封装了一个值
- 想要处理盒子中的值，我们需要给盒子的map方法传递一个处理值的函数（纯函数)，由这个函数来对值进行处理
- 最终map方法返回一个包含新值的盒子(函子)

**maybe函子**
maybe函子为了避免函子传入空值（null/undefined）情况的发生，它作用就是可以对外部的空值情况做处理（控制副作用在允许的范围）

**either函子**
 异常会让函数变的不纯，通过either函子去处理异常，可以记录错误信息。类似于 if...else...的处理。

**IO函子**
IO函子中的_value是一个函数，这里把函数当做值来处理。IO函子把不纯的操作存储到_value中交给调用者去处理，延迟不纯的操作，包装当前的纯操作。缺点是嵌套函子很不方便。

**task函子**
task用于解决异步任务，和promise非常像，返回方法是resolver.resolve、resolver.reject，调用方法有.run()、.listen({onRejected/onResolved)}等。

> folktale是一个标准的函数式编程库，和lodash、ramda不同的是，他没有提供很多功能函数，只提供了一些函数式处理的操作，例如: compose、curry等，一些函子Task、Either、MayBe等
folktale的基本使用<https://folktale.origamitower.com/>

**pointed函子**
pointed函子只是一个概念而已，是实现了 of 静态方法的函子

**monad函子**
monad函子是可以变扁的pointed函子，一个函子如果具有join和of两个方法并遵守一些定律就是一个monad。
- 处理值用map
- 处理函数用flatMap

#### 函数式编程总结
1，可读性强：声明式(Declarative)使得代码即使没有注释也有很高的可读性(这也是 React 的一大卖点)。
2，代码量少：项目越大，越节省代码量(大量的函数被复用)。
3，代码稳定可靠：纯函数的功劳。
4，容易维护性：符合「单一职能原则」，使得代码的维护与迭代更加容易。



