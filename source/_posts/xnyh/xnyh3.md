---
title: 浏览器性能优化(请求和响应优化)
date: 2022-02-16 10:52:05
categories: 
- 高级前端笔记
tags: 
- 性能优化
---


#### 请求和响应优化介绍
目的:更快的内容到达时间。
核心思路:
1.更好的连接传输效率
2.更少的请求数量
3.更小的资源大小
4.合适的缓存策略

最佳实践:
1.减少DNS查找:每次主机名的解析都需要一次网络往返，从而增加了请求的延迟时间，同时还会阻塞后续的请求。
2．重用TCР 连接:尽可能的使用持久连接，以消除因TCP握手和慢启动导致的延迟。
3.减少HTTP重定向:HTTP冲定向需要额外的DNS查询、TCP握手等非常耗时，最佳的重定向次数为0。
4．压缩传输的资源:比如Gzip、图片压缩。
5．使用缓存:比如HTTP缓存、CDN缓存、Service Worker 缓存。
6.使用CDN(内容分发网络)︰把数据放在离用户地理位置更近的地方，可以明显减少每次TCP连接的网络延迟，增大吞吐星,
7．删除没有必要请求的资源。
8．在客户端缓存资源:缓存必要的应用资源，避免每次都重复请求相同的内容，例如多图片下载可以考虑使用缓存。
9.内容在传输前先压缩:传输数据之前应该先压缩应用资源，把要传输的字节减少到最小，在压缩的时候确保对每种不同的资源采用最好的压缩手段。
10．消除不必要的请求开销:减少请求的HTTP首部数据(比如HTTP COokie)
11.并行处理请求和响应:请求和响应的排队都会导致延迟，可以尝试并行的处理请求和响应(利用多个HTP11连接实现并行下载，在可能的情况下使用HTP管道计数)，
12．针对协议版本采取优化措施。升级到HTTP2.0。
拉勾教
13．根据需要采用服务端渲染方式。这种方式可以解决SPA应用首屏渲染慢的问题。
14．采用预渲染的方式快速加载静态页面。页面渲染的极致性能，比较适合静态页面。

##### DNS解析优化
减少DNS的查找和请求次数
进行DNS预获取:DNS Prefetch 《link ref="dns-prefetch" href="">
- 不要预解析当前域
- 不要多页面重复预解析
- 禁用预解析<meta http-equiv="x-dns-prefetch-control" content="off">
延长dns缓存时间
使用cdn加速域名
搭建自己的dns服务

##### http长连接
tcp连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。
持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早的结束，这样Web页面的显示速度也就相应提高了。
缺点是响应是串行的 很容易队头堵塞
为了避免有两种办法，一个是减少请求数，一个是同时多开持久连接

##### http2
http2的前身是谷歌自行研发的SPDY协议
**二进制协议**
**多工**
HTTP/2复用TCР连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一—对应，这样就避免了"队头堵塞"。
并发请求 并发响应，这样双向的、实时的通信，就叫做多工(Multiplexing) 。
**数据流**
HTTP/2将每个请求或回应的所有数据包，称为一个数据流(stream)。每个数据流都有-个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。
数据流发送到一半的时候，客户端和服务器都可以发送信号(RST_STREAM帧)，取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP 连接。这就是说，HTTP/2可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。
客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。
**头信息压缩**
HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。
HTTP/2对这一点做了优化，引入了头信息压缩机制(header compression)。一方面，头信息使用gzip或compress压缩后再发送;另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。
**服务器推送**
HTTP/2允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送(serverpush) 。
你跟服务器要饭，他知道你缺碗还一块给了你一个碗

##### 压缩传输的数据资源
**响应数据的压缩**
Gzip压缩文本 compression

**请求数据的压缩**
请求头：h1是不能压缩的，HTTP/2对这一点做了优化，引入了头信息压缩机制（header compression)
请求体：开发人员通过代码压缩（3种常见的压缩算法），后台也要提供解压
实际使用还需要匹配具体的服务器，比如nginx、Apache 等。


##### http缓存
缓存的原理是在首次请求后保存一份请求资源的响应副本，当用户再次发起相同请求后，如果判断缓存命中则拦截请求，将之前存储的响应副本返回给用户，从而避免重新向服务器发起资源请求。

缓存的技术种类有很多，比如代理缓存、浏览器缓存、网关缓存、负载均衡器及内容分发网络等，它们大致可以分为两类:共享缓存和私有缓存。共享缓存指的是缓存内容可被多个用户使用，如公司内部架设的Web代理;私有缓存指的是只能单独被用户使用的缓存，如浏览器缓存

HTTP缓存应该算是前端开发中最常接触的缓存机制之一，它又可细分为强制缓存与协商缓存，二者最大的区别在于判断缓存命中时，浏览器是否需要向服务器端进行询问以协商缓存的相关信息，进而判断是否需要就响应内容进行重新请求。下面就来具体看HTTP缓存的具体机制及缓存的决策策略。

**强制缓存**
其中与强制缓存相关的两个字段是expires（过期时间）和cache-control,

从上述强制缓存是否过期（expires）的判断机制中不难看出，这个方式存在一个很大的漏洞，即对本地时间戳过分依赖，如果客户端本地的时间与服务器端的时间不同步，或者对客户端时间进行主动修改，那么对于缓存过期的判断可能就无法和预期相符。

为了解决expires判断的局限性，从HTT1.1协议开始新增了cache-control字段来对expires的功能进行扩展和完善。

cache-control的配置
- no-cache（强制协商缓存） 和no-store（不缓存）
- private（只能被浏览器缓存）和public（代理服务器也能缓存（如图像 css js等静态文件））也是cache-control的一组互斥属性值，它们用以明确响应资源是否可被代理服务器进行缓存。
- max-age（缓存时间）属性值会比s-maxage（代理缓存时间（public时才生效））更常用，它表示服务器端告知客户端浏览器响应资源的过期时长。

由此可见cache-control能作为expires的完全替代方案，并且拥有其所不具备的一些缓存控制特性，在项目实践中使用它就足够了，目前expires还存在的唯一理由是考虑可用性方面的向下兼容。

**协商缓存**
顾名思义，协商缓存就是在使用本地缓存之前，需要向服务器端发起一次GET请求，与之协商当前浏览器保存的本地缓存是否已经过期。所以需要向服务器发送一次GET请求，进行缓存有效性的协商，此次GET请求的请求头中需要包含一个ifmodified-since字段，其值正是上次响应头中last-modified的字段值。
```js
res.setHeader( 'last-modified ' , mtime.toUTCString())
res.setHeader( 'Cache-Control' , 'no-cache " )
```
首先它只是根据资源最后的修改时间戳进行判断的，虽然请求的文件资源进行了编辑，但内容并没有发生任何变化，时间戳也会更新，从而导致协商缓存时关于有效性的判断验证为失效，需要重新进行完整的资源请求。这无疑会造成网络带宽资源的浪费，以及延长用户获取到目标资源的时间。

其次标识文件资源修改的时间戳单位是秒，如果文件修改的速度非常快，假设在几百毫秒内完成，那么上述通过时间戳的方式来验证缓存的有效性，是无法识别出该次文件资源的更新的。

基于ETag(指纹）的协商缓存：
其内容主要是服务器为不同资源进行哈希运算所生成的一个字符串，该字符串类似于文件指纹，只要文件内容编码存在差异，对应的ETag标签值就会不同，因此可以使用ETag 对文件资源进行更精准的变化感知。
```js
// 安装etag包并加载
const data = fs.readFilesync( './img/04.jpg )
const etagcontent = etag(data)
res.setHeader( 'etag ', etagContent)
res.setHeader( 'Cache-Control' , 'no-cache " )
```
一方面服务器对于生成文件资源的ETag需要付出额外的计算开销，如果资源的尺寸较大，数量较多且修改比较频繁，那么生成ETag的过程就会影响服务器的性能。

另一方面ETag字段值的生成分为强验证和弱验证，强验证根据资源内容进行生成，能够保证每个字节都相向;弱验证则根据资源的部分属性值来生成，生成速度快但无法确保每个字节都相同，并且在服务器集群场景下，也会因为不够准确而降低协商缓存有效性验证的成功率，所以恰当的方式是根据具体的资源使用场景选择恰当的缓存校验方式。

**缓存的注意事项**
这里建议你能够根据该决策树的流程去设置缓存策略，这样不但会让指定的策略有很高的可行性，而且对于理解缓存过程中的各个知识点也非常有帮助。
我们可以将一个网站所需要的资源按照不同类型去拆解，为不同类型的资源制定相应的缓存策略，以下面的HTML文件资源为例:

首先HTML在这里属于包含其他文件的主文件，为保证当其内容发生修改时能及时更新，应当将其设置为协商缓存，即为cache-control 字段添加no-cache属性值;其次是图片文件，因为网站对图片的修改基本都是更换修改，同时考虑到图片文件的数量及大小可能对客户端缓存空间造成不小的开销，所以可采用强制缓存且过期时间不宜过长，故可设置cache-control字段值为max-age=86400。

接下来需要考虑的是样式表文件style.css，由于其属于文本文件，可能存在内容的不定期修改，又想使用强制缓存来提高重用效率，故可以考虑在样式表文件的命名中增加文件指纹或版本号（(比如添加文件指纹后的样式表文件名变为了style.51ad84f7.css)，这样当发生文件修改后，不同的文件便会有不同的文件指纹，即需要请求的文件 URL不同了，因此必然会发生对资源的重新请求。同时考虑到网络中浏览器与CDN等中间代理的缓存，其过期时间可适当延长到一年，即cache-control: max-age=31536000。

最后是JavaScript脚本文件，其可类似于样式表文件的设置;采取文件指纹和较长的过期时间，如果JavaScript中包含了用户的私人信息而不想让中间代理缓存，则可为cache-control添加private属性值。

从这个缓存策略的示例中我们可以看出，对不同资源进行组合使用强制缓存、协商缓存及文件指纹或版本号，可以做到一举多得:及时修改更新、较长缓存过期时间及控制所能进行缓存的位置。

拆分源码，分包加载
预估资源的缓存时效
控制中间代理的缓存
避免网址的冗余
规划缓存的层次结构

**cdn缓存**
CDN网络能够缓存网站资源来提升首次请求的响应速度，但并非能适用于网站所有资源类型，它往往仅被用来存放网站的静态资源文件。所谓静态资源，就是指不需要网站业务服务器参与计算即可得到的资源，包括第三方库的JavaScript脚本文件、样式表文件及图片等，这些文件的特点是访问频率高、承载流量大，但更新修改频次低，且不与业务有太多耦合。

如果是动态资源文件，比如依赖服务器端渲染得到的 HTML页面，它需要借助服务器端的数据进行计算才能得到，所以它就不适合放在CDN缓存服务器上。



#### 写在最后

原创博文, 如有错误, 敬请指导!