
---
title: 浏览器性能优化(渲染优化)
date: 2022-02-24 10:52:05
categories: 
- 高级前端笔记
tags: 
- 性能优化
---



#### 渲染优化
浏览器从获取HTML到最终在屏幕上显示内容需要完成以下步骤:
1.处理HTML标记并构建DOM树。
2.处理CSS标记并构建CSSOM树。
3.将DOM与CSSOM合并成一个render tree。
4.根据渲染树来布局，以计算每个节点的几何信息。
5.将各个节点绘制到屏幕上。


JavaScript处理:前端项目中经常会需要响应用户操作，通过JavaScript对数据集进行计算、操作DOM元素，并展示动画等视觉效果。当然对于动画的实现，除了JavaScript，也可以考虑使用如CSS Animations、Transitions 等技术。
计算样式:在解析CSS文件后，浏览器需要根据各种选择器去匹配所要应用CSS规则的元素节点，然后计算出每个元素的最终样式。
页面布局:指的是浏览器在计算完成样式后，会对每个元素尺寸大小和屏幕位置进行计算。由于每个元素都可能会受到其他元素的影响，并且位于DOM树形结构中的子节点元素，总会受到父级元素修改的影响，所以页面布局的计算会经常发生。
绘制:在页面布局确定后，接下来便可以绘制元素的可视内容，包括颜色、边框、阴影及文本和图像。
合成:通常由于页面中的不同部分可能被绘制在多个图层上，所以在绘制完成后需要将多个图层按照正确的顺序在屏幕上合成，以便最终正确地渲染出来。

##### 优化dom
html文件的尺寸应该尽可能小：总结起来有三种方式可以优化HTML:缩小文件的尺寸(Minify) 、使用gzip压缩(Compress)、使用缓存(HTTPCache) 。

##### 优化cssom
css的加载会阻塞网络渲染，避免在css种使用@import
```js
//阻塞渲染
<link href="style.css" rel="stylesheet">
//非阻塞(打印的样式）
<link href="print.css" rel="stylesheet" media="print">
//非阻塞（媒体查询）(可变阻塞）
<link href="other.css" rel="stylesheet" media="(min-width: 40em)">
<link href=" portrait.css" rel="stylesheet" media="orientation : portrait">
```

##### 优化js
异步加载JavaScript
避免同步请求
延迟解析JavaScript
避免运行时间长的JavaScript

```js
/*具有defer特性的脚本不会阻塞页面。
具有defer特性的脚本总是要等到DOM
解析完毕，但在DOMContentLoaded事
件之前执行。
*/
//如果有多个，会异步并行加载，按顺序执行
<script defer src="index.js"></ script>
//如果有多个，会异步并行加载，按时间长短执行
<script async src="index.js"></ script>
```
```js
// script放在最底部  可以head里这样利用空闲时间预加载
<link rel="preload" href="index.js">
<link rel="preload" href="index2.js">
// script放在最底部  可以预加载可能用到的非当前页面的资源
<link rel="prefetch" href="index.js">

```

##### js执行优化
实现动画效果：能用css就不用js。使用js时每秒60帧最好
实践经验告诉我们，使用定时器实现的动画会在世些低端机器上出现抖动或者卡顿的现象，这主要是因为浏览器无法确定定时器的回调函数的执行时机。以 setInterval为例，其创建后回调任务会被放入异步队列，只有当主线程上的任务执行完成后，浏览器才会去检查队列中是否有等待需要执行的任务，如果有就从任务队列中取出执行，这样会使任务的实际执行时机比所设定的延迟时间要晚一些。

其次屏幕分辨率和尺寸也会影响刷新频率，不同设备的屏幕绘制频率可能会有所不同，而setInterval只能设置某个固定的时间间隔，这个间隔时间不一定与所有屏幕的刷新时间同步，那么导致动画出现随机丢帧也在所难免。

为了避免这种动画实现方案中因丢帧而造成的卡顿现象，我们推荐使用
window. requestAnimationFrame（兼容到ie10）方法。与setInterval方法相比，其最大的优势是将回调函数的执行时机交由系统来决定，即如果屏幕刷新频率是60Hz，则它的回调函数大约会每16.7ms 执行一次，如果屏幕的刷新频率是75Hz，则它回调函数大约会每13.3ms执行一次，就是说requestAnimationFrame方法的执行时机会与系统的刷新频率同步。
这样就能保证回调函数在屏幕的每次刷新间隔中只被执行一次，从而避免因随机丢帧而造成的卡顿现象。

##### 恰当的使用web worker
众所周知JavaScript是单线程执行的，为此可将一些纯计算的工作迁移到 Web Worker上处理，它为JavaScript的执行提供了多线程环境，主线程通过创建出 Worker子线程，可以分担一部分自己的任务执行压力。在Worker子线程上执行的任务不会干扰主线程，待其上的任务执行完成后，会把结果返回给主线程，,这样的好处是让主线程可以更专注地处理UI交互，保证页面的使用体验流程。需要注意的是，Worker子线程一旦创建成功就会始终执行，不会被主线程上的事件所打断，这就意味着Worker 会比较耗费资源，所以不应当过度使用，一旦任务执行完毕就应及时关闭。除此之外，在使用中还有以下几点应当注意.

DOM限制:Worker无法读取主线程所处理网页的DOM对象，也就无法使用document、window和parent等对象，只能访问navigator和location对象。
文件读取限制: Worker子线程无法访问本地文件系统，这就要求所加载的脚本来自网络。
通信限制:主线程和Worker子线程不在同一个上下文内，所以它们无法直接进行通信，只能通过消息来完成。
脚本执行限制:虽然 Worker可以通过XMLHTTPRequest对象发起ajax请求，但不能使用alert()方法和confirm()方法在页面弹出提示。
同源限制: Worker子线程执行的代码文件需要与主线程的代码文件同源。
```js
const worker = new Worker( 'worker.js ')
```
在子线程处理完相关任务后，需要及时关闭Worker子线程以节省系统资源，关闭的方式有两种:
·在主线程中通过调用worker.terminate()方法来关闭;
·在子线程中通过调用自身全局对象中的self.close()方法来关闭。


##### 防抖和节流
```js
//参数1:函数//参数2:时间
//返回值:被防抖的函数
document.onscroll = _.debounce(function ( { console.log( 'hello')
 },500)
 
//参数1:函数//参数2:时间
//返回值:被节流的函数
document.onscroll = _.throttle(function ( { console.log( 'hello')
 },500)
```

##### 计算样式优化
减少要计算样式的元素数量
首先我们需要知道与计算样式相关的一条重要机制: csS引擎在查找样式表时，对每条规则的匹配顺序是从右向左的，这与我们通常从左向右的书写习惯相反。
(1)使用类选择器替代标签选择器，
(2）避免使用通配符做选择器
```css
* {
margin: 0;
padding: 0;
}
```
这种操作在标签规模较小的demo 项目中，几乎看不出有任何性能差异。但对实际的工程项目来说，使用通配符就意味着在计算样式时，浏览器需要去遍历页面中的每一个元素，这样的性能开销很大，应当避免使用。
(3)降低选择器的复杂度
(4)使用BEM规范: BEM是一种CSS的书写规范，它的名称是由三个单词的首字母组成的，分别是块(Block) 、元素(Element)和修饰符(Modifier)。理论上它希望每行CSS代码只有一个选择器，这就是为了降低选择器的复杂性，对选择器的命名要求通过以下三个符号的组合来实现。
中画线(-)︰仅作为连字符使用，表示某个块或子元素的多个单词之间的连接符。
单下画线(\_)︰作为描述一个块或其子元素的一种状态。
双下画线(\_\_)︰作为连接块与块的子元素。
```css
//常规写法
.mylist {}
.mylist .item {}
//BEM写法
.mylist {}
.mylist__item {}
```

##### 页面布局与重绘
页面布局也叫作重排和回流，指的是浏览器对页面元素的几何属性进行计算并将最终结果绘制出来的过程。凡是元素的宽高尺寸、在页面中的位置及隐藏或显示等信息发生改变时，都会触发页面的重新布局。
如果仅仅修改了DOM元素的样式，而未影响其几何属性时，则浏览器会跳过页面布局的计算环节，直接进入重绘阶段。

##### 总结
尽量避免对样式的频繁改动
尽量使用更改类名对元素样式进行修改
缓存对敏感属性值的计算
使用requestAnimationFrame方法控制渲染帧（这里面的offsetHeight等是上一轮获取的 不用重新计算）




#### 写在最后

原创博文, 如有错误, 敬请指导!