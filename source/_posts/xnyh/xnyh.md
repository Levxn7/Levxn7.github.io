---
title: JS的性能优化
date: 2021-04-13 10:52:05
categories: 
- 高级前端笔记
tags: 
- 性能优化
- 内存管理
- 垃圾回收
- V8
- GC算法
---

#### 性能优化
对于JavaScript来说, 会在创建变量（对象, 字符串等）时分配内存, 并且在不再使用它们时“自动”释放内存, 这个自动释放内存的过程称为垃圾回收。因为自动垃圾回收机制的存在, 让大多Javascript开发者感觉他们可以不关心内存管理, 所以会在一些情况下导致内存泄漏。

内容概要：
- 内存管理
- 垃圾回收与常见GC算法
- V8引擎的垃圾回收
- Performance工具
- 代码优化实例

**内存管理**
如果不好好做内存管理, 会导致内存泄漏
内存管理的声明周期: 申请, 使用, 释放

**垃圾回收**
JS 有自动垃圾回收机制, 那么这个自动垃圾回收机制的原理是什么呢？其实很简单, 对象不再被引用时就是垃圾, 就是找出那些不再继续使用的值, 然后释放其占用的内存。
大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到不再需要使用的变量。
已存在的对象, 让我们不能从根上访问时也是垃圾

**引用与可达对象**
垃圾回收算法主要依赖于引用的概念。
在内存管理的环境中, 一个对象如果有访问另一个对象的权限（隐式或者显式）, 叫做一个对象引用另一个对象。
从根上可以找到的对象是可达对象.


#### GC算法
gc就是垃圾回收机制的简写, gc可以找到内存中的垃圾, 并释放和回收空间

**gc里的垃圾是什么**
程序中不再需要的对象
程序组不能再访问到的对象

**常见的gc算法**
- 引用计数
- 标记清除
- 标记整理
- 分代回收


##### 引用计数算法实现原理
核心思想: 设置引用数, 判断当前引用数是否为0
- 给对象中添加一个引用计数器, 每当有一个地方引用它时, 计数器值就加1
- 当引用失效时, 计数器值就减1；
- 任何时刻计数器为0的对象就是不可能再被使用的。
- 引用数字为0时立即回收

> 优点

会立即回收垃圾
最大限度减少程序暂停（卡顿））

> 缺点

无法回收循环引用的对象（互相引用）
时间开销大（资源消耗打）


##### 标记清除算法实现原理
标记清除算法是现代垃圾回收算法的思想基础。
标记清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。
- 在标记阶段, 首先通过根节点, 标记所有从根节点开始的可达对象。未被标记的对象就是未被引用的垃圾对象；
- 在清除阶段, 清除所有未被标记的对象。
- 回收相应的空间, 放在空闲链表上方便以后申请使用

> 优点

可以解决循环引用回收操作

> 缺点

空间碎片化
释放的地址空间不连续
不会立即回收垃圾对象（回收时停止工作）


##### 标记整理实现原理
标记整理可以看做是标记清除的增强版
- 标记阶段的操作和标记清除一致
- 清除阶段会先执行整理,移动对象位置

标记整理回收的空间基本是连续的, 不会立即回收垃圾对象


##### 常见gc算法总结
参考资料:
<https://blog.csdn.net/qq_40028324/article/details/92970588>
<https://www.cnblogs.com/qianguyihao/p/4744233.html>


#### V8
V8是一款主流的JavaScript执行引擎, 采用即时编译, 内存设限为64位操作系统1.5G,32位操作系统800M

**v8垃圾回收策略**
采用分代回收的思想, 内存分为新生代、老生代, 针对不同对象采用不同算法

**V8中常用GC算法**
- 分代回收
- 空间复制
- 标记清除
- 标记整理
- 标记增量

**v8内存分配**
V8内存空间一分为二, 小空间用于存储新生代对象（64位32M | 32位16M)

##### 分代回收算法原理
**新生代对象**
内存分为新生代和老生代, 新生代指的是存活时间较短的对象

新生代对象回收实现
- 回收过程采用复制算法＋标记整理
- 新生代内存区分为两个等大小空间, 使用空间为From, 空闲空间为To, 活动对象存储于From空间
- 标记整理后将活动对象拷贝至To空间
- From与To交换空间完成释放

**老年代对象**
老年代对象就是指存活时间较长的对象, 存放在右侧老生代区域(64位操作系统1.4G,32操作系统700M)

老年代对象回收实现
- 主要采用标记清除、标记整理、增量标记算法·首先使用标记清除完成垃圾空间的回收
- 采用标记整理进行空间优化
- 采用增量标记进行效率优化

**新老对比**
新生代区域垃圾回收使用空间换时间, 使用复制和整理算法
老生代区域垃圾回收不适合复制算法, 使用标记清除, 标记整理, 标记增量

##### v8引擎工作流程
扫描器 解析器
预解析优点
·跳过未被使用的代码
·不生成AST, 创建无变量引用和声明的scopes·依据规范抛出特定错误
解析速度更快

全量解析
·解析被使用的代码·生成AST
·构建具体scopes信息,变量引用、声明等·抛出所有语法错误

lgnition是V8提供的一个解释器
TurboFan是V8提供的编译器模块


##### 总结
- V8是一款主流的 JavaScript 执行引擎
- V8内存设置上限（用户感知不到）
- V8采用基于分代回收思想实现垃圾回收
- V8内存分为新生代和老生代


#### performance介绍
我们为什么使用 Performance? 
GC的目的是为了实现内存空间的良性循环, 良性循环的基石是合理使用, 时刻关注才能确定是否合理.
Performance为我们提供多种监控方式, 通过Performance可以时刻监控内存

**内存问题的体现**
1.页面出现延迟加载或经常性暂停
2.页面持续性出现糟糕的性能
3.页面的性能随时间延长越来越差

**界定内存问题的标准**
1.内存泄露: 内存使用持续升高
2.内存膨胀: 在多数设备上都存在性能问题
3.频繁垃圾回收: 通过内存变化图进行分析

**监控内存的几种方式**
浏览器任务管理器
Timeline时序图记录
堆快照查找分离DOM
判断是否存在频繁的垃圾回收

**任务管理器监控内存变化**（Shift+esc）
timeline（在性能里）
堆快照查找分离dom

**判断是否频繁gc**
为什么确定频繁垃圾回收
GC工作时应用程序是停止的
频繁且过长的GC会导致应用假死
用户使用中感知应用卡顿


#### 堆栈内存操作
**堆栈准备**
- JS执行环境
- 执行环境栈（ECStack, execution context stack): 执行上下文
- Vo(G): 全局变量对象

**引用类型堆栈**
1.变量提升：（声明）
2.代码执行：（赋值）
3.放对象的是堆内存
4.对象存的是地址

**函数堆栈**
函数创建
- 可以将函数名称看做是变量，存放在 VO 当中 ，同时它的值就是当前函数对应的内存地址
- 函数本身也是一个对象，创建时会有一个内存地址，空间内存放的就是函数体代码（字符串形式的）

函数执行
- 函数执行时会形成一个全新私有上下文，它里面有一个AO 用于管理这个上下文当中的变量
- 步骤：
 01 作用域链 <当前执行上下文， 上级作用域所在的执行上下文>
 02 确定 this
 03 初始化 arguments （对象）
 04 形参赋值：它就相当于是变量声明，然后将声明的变量放置于 AO
 05 变量提升
 06 代码执行
 
这里由函数内存处理可以引出闭包

**闭包堆栈处理**
函数调用形成了一个全新的私有上下文，在函数调用之后当前上下文不被释放就形成了闭包（临时不被释放）
闭包是一种机制
 保护：当前上下文当中的变量与其它的上下文中变量互不干扰
 保存：当前上下文中的数据（堆内存）被当前上下文以外的上下文中的变量所引用，这个数据就保存下来了
```js
var a = 1
function foo() {
  var b = 2
  return function (c) {
    console.log(c + b++)
  }
}

var f = foo()
f(5)
f(10)
```

**jsbench.me**
jsbench是一个网站, 它可以比较两段代码运行的速度, 对性能优化很方便, 使用方法也很简单, 这里不多做描述
下面列举的例子都可以通过这个网站来观察运行速度

**变量局部化**
这样可以提高代码的执行效率（ 减少了数据访问时需要查找的路径 ）
函数嵌套时, 定义离使用处越近越好
```js
var i, str = ""
function packageDom() {
  for (i = 0; i < 1000; i++) {
    str += i
  }
}
packageDom()

function packageDom() {
  let str = ''
  for (let i = 0; i < 1000; i++) {
    str += i
  }
}

packageDom()
```

**缓存数据**
对于需要多次使用的数据进行保存 方便后续使用
把本该 去其他房间的东西存到自己房间(查找作用域链会变快)
```js
var oBox = document.getElementById('skip')
// 假设在当前的函数体当中需要对 className 的值进行多次使用，那么我们就可以将它提前缓存起来
function hasClassName(ele, cls) {
    console.log(ele.className)
    return ele.className == cls
}
console.log(hasClassName(oBox, 'skip'))


function hasClassName(ele, cls) {
    var clsName = ele.className
    console.log(clsName)
    return clsName == cls
}
console.log(hasClassName(oBox, 'skip'))
```

**减少访问层级**
```js
// var obj = {
//   age: 18, 
//   methods: {
//     m1: {
//       name: '', 
//       time: 100
//     },
//     m2: {
//       name: '',

//     }
//   }
// }
//以上代码层级过多, 运行速度会慢

function Person() {
  this.name = 'zce'
  this.age = 40
}

let p1 = new Person()
console.log(p1.age)

function Person() {
  this.name = 'zce'
  this.age = 40
  this.getAge = function () {
    return this.age
  }
}

let p1 = new Person()
console.log(p1.getAge())
```

**防抖与节流**
这部分知识我单独写了一篇文章, [摸下这里可以跳过去查看](https://levxn7.github.io/2021/06/03/fdjl/)
 
**减少判断层级**
应当提前return无用的条件
如果有很多else if建议使用swich case

**减少循环体活动**

**字面量与构造式**


#### 写在最后
参考资料: 
<https://zhuanlan.zhihu.com/p/81767710>

原创博文, 如有错误, 敬请指导!




